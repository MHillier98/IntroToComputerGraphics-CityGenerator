<html>

<head>
  <title>Procedural City Generator</title>
</head>

<style>
  body {
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }
</style>

<body>
  <!--include the three.js library-->
  <script src="js/three.js"> </script>
  <!--and the trackball code-->
  <script src="js/OrbitControls.js"> </script>
  <!--the model loader-->
  <script src="js/PLYLoader.js"></script>
  <!--the GUI-->
  <script src="js/dat.gui.min.js"></script>

  <style>
    body {
      font-family: Monospace;
      background-color: #000;
      color: #fff;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
    }
  </style>

  <div id="info">
  </div>
  <script>
    //create the scene
    var scene = new THREE.Scene();
    var ratio = window.innerWidth / window.innerHeight;
    //create the perspective camera
    //for parameters see https://threejs.org/docs/#api/cameras/PerspectiveCamera
    var camera = new THREE.PerspectiveCamera(80, ratio, 0.1, 100000);

    //set the camera position
    var Pos = new THREE.Vector3(-360, 700, 360);
    camera.position.set(Pos.x, Pos.y, Pos.z);

    // and the direction
    var Dir = new THREE.Vector3(0, 0, 0);
    camera.lookAt(Dir.x, Dir.y, Dir.z);

    //Skybox
    var skyboxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
    var skyboxMaterials = [
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load("./assets/skybox/hills_ft.png"),
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load("./assets/skybox/hills_bk.png"),
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load("./assets/skybox/hills_up.png"),
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load("./assets/skybox/hills_dn.png"),
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load("./assets/skybox/hills_rt.png"),
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load("./assets/skybox/hills_lt.png"),
        side: THREE.DoubleSide
      }),
    ];

    // var skyboxMaterial = new THREE.MeshBasicMaterial(skyboxMaterials);
    var skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);




    // generate the city!

    var baseGeometry = new THREE.PlaneGeometry(2000, 2000);
    var baseMaterial = new THREE.MeshPhongMaterial({
      map: new THREE.TextureLoader().load("./assets/skybox/hills_dn.png"),
      side: THREE.DoubleSide
    });
    var baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
    baseMesh.rotation.set(Math.PI / 2, 0, 0);
    baseMesh.receiveShadow = true;
    baseMesh.castShadow = false;
    scene.add(baseMesh);



    var roadSize = 20;

    var roadGeometry = new THREE.PlaneGeometry(roadSize, roadSize);
    var roadMaterial = new THREE.MeshPhongMaterial({
      map: new THREE.TextureLoader().load("./assets/road/asphalt.png"),
      side: THREE.DoubleSide
    });


    var roadLocations = [];

    function AddSquareRoad(x, y, z) {


      var roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
      roadMesh.receiveShadow = true;
      roadMesh.castShadow = false;

      roadMesh.position.y = y;
      roadMesh.position.z = z;
      roadMesh.position.x = x;
      roadMesh.rotation.set(Math.PI / 2, 0, 0);

      scene.add(roadMesh);
    }

    function AddRoads(x, y, z, width) {

      var freeSpace = true;

      for (var b = 0; b < roadLocations.length; b++) {
        if (roadLocations[b].x == x && roadLocations[b].z == z) {
          freeSpace = false;
        }
      }

      if (freeSpace) {
        // console.log("road");

        roadLocations.push({
          x,
          z
        });

        for (var w = 0; w < width; w++) {
          AddSquareRoad((w + x) * roadSize, y, z * roadSize);
        }

        for (var q = 0; q < width; q++) {
          AddSquareRoad(x * roadSize, y, (q + z) * roadSize);
        }
      }
    }

    // function LayoutRoad(width, spacing, height) {
    //   for (var j = -width; j < width; j++) {
    //     AddSquareRoad(j * roadSize, height, width * roadSize);
    //     if (j % spacing == 0) {
    //       for (var k = -width; k < (width + 1); k++) { // +1 so we fill in the final corner
    //         AddSquareRoad(width * roadSize, 1, k * roadSize);
    //         if (k % spacing == 0 && k < width) { //k < width to let us get the corner
    //           AddRoads(j, height, k, spacing);
    //         }
    //       }
    //     }
    //   }
    // }
    // this lays out a full grid over the full base
    //LayoutRoad(40, 5, 3); 


    var buildingLocations = [];

    function AddBuilding(startingX, startingZ, randomX, randomZ) {
      var buildingWidth = 1.5 + (Math.random() * 1);
      var buildingHeight = 1.2 + (Math.random() * 1.8);

      var buildingX = (startingX + randomX) * 20 * 5;
      var buildingY = buildingHeight / 2
      var buildingZ = (startingZ + randomZ) * 20 * 5;

      var freeSpace = true;

      for (var b = 0; b < buildingLocations.length; b++) {
        if (buildingLocations[b].buildingX == buildingX && buildingLocations[b].buildingZ == buildingZ) {
          freeSpace = false;
        }
      }

      if (freeSpace) {
        buildingLocations.push({
          buildingX,
          buildingZ
        });

        var baseColor = 0.2 + (Math.random() * 0.8);
        AddBuild(Math.floor((Math.random() * 8) + 1), baseColor - (Math.random() / 10), baseColor - (Math.random() /
            10), baseColor - (Math.random() / 10), buildingWidth, buildingHeight, buildingWidth, buildingX, buildingY,
          buildingZ);
      }
    }

    //AddBuild(name of model, red, blue, green, width, height, depth, x translation, y translation, z translation)
    //AddBuild(1, 0.5, 0.5, 0.5, 1, 1, 1, 0, 0, 0);
    function AddBuild(model, r, g, b, width, height, depth, xTra, yTra, zTra) {
      var loader = new THREE.PLYLoader();
      var mesh = null;
      loader.load('assets/building_models/b' + model + '.ply', function (geometry) {
        var material = new THREE.MeshPhongMaterial();
        material.color = new THREE.Color(r, g, b);
        material.shininess = 100;
        geometry.computeVertexNormals();
        mesh = new THREE.Mesh(geometry, material);
        mesh.name = "building";

        geometry.computeBoundingBox();

        //var center = geometry.boundingBox.getCenter();
        var size = geometry.boundingBox.getSize();

        var sca = new THREE.Matrix4();
        //var tra = new THREE.Matrix4();
        //var rot = new THREE.Matrix4();
        var combined = new THREE.Matrix4();

        sca.makeScale(2 * size.length() * width, 2 * size.length() * height, 2 * size.length() * depth);
        //tra.makeTranslation (center.x + xTra, center.y + yTra, center.z + zTra);
        //rot.makeRotationX(- Math.PI / 2);

        combined.multiply(sca);
        //combined.multiply(tra);
        //combined.multiply(rot);

        mesh.applyMatrix(combined);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        mesh.position.x = xTra;
        mesh.position.y = yTra;
        mesh.position.z = zTra;

        scene.add(mesh);

      });
    }




    function RandomWalk(startingX, startingZ, stepsLeft, spacing) {
      var randomRoadCoords = [
        [0, 1],
        [0, -1],
        [-1, 0],
        [1, 0]
      ][Math.random() * 4 | 0];

      var newX = startingX + randomRoadCoords[0];
      var newZ = startingZ + randomRoadCoords[1];

      AddRoads(newX * 5, 2, newZ * 5, 5);


      var randomBuildingCoords = [
        [0.5, 0.5],
        [0.5, -0.5],
        [-0.5, 0.5],
        [-0.5, -0.5]
      ][Math.random() * 4 | 0];

      AddBuilding(startingX, startingZ, randomBuildingCoords[0], randomBuildingCoords[1]);


      var newStepsLeft = stepsLeft - 1;
      if (newStepsLeft > 0) {
        RandomWalk(newX, newZ, newStepsLeft, spacing);
      }
    }

    function GenerateCity(steps) {
      for (var x = 0; x < steps; x++) {
        RandomWalk(0, 0, x, 5);
      }
    }

    var genSteps = 3;

    GenerateCity(genSteps);


    var raycaster = new THREE.Raycaster();
    var selectedObject = new THREE.Mesh();
    selected_building = selectedObject.name;
    var selectedObjectColor = new THREE.Color();
    var selectedObjectScale;
    var isSelected = false;

    function onDocumentMouseDown(event) {
      switch (event.button) {
        case 0: //left
          var mouse = new THREE.Vector2;
          mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
          mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
          if (mouse.x < 0.42) {
            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children, false);

            if (intersects.length > 0) {
              if ((intersects[0].object.name == "building") && (!isSelected)) {
                // console.log("Selected!");
                selectedObject = intersects[0].object;
                selectedObjectColor = selectedObject.material.color;
                selectedObjectScale = selectedObject.scale.y;
                // console.log(selectedObjectScale);
                selectedObject.material.color = new THREE.Color(1, 0.5, 0.5);
                isSelected = true;
                selectCheck();
              }
              if ((intersects[0].object.name != "building") && (isSelected)) {
                selectedObject.material.color = selectedObjectColor;
                var pos = intersects[0].point;
                // console.log("Placed!");
                selectedObject.position.x = pos.x;
                selectedObject.position.z = pos.z;
                isSelected = false;
              }
            }
          }
          // console.log(scene);
          break;
        case 1: //middle
          break;
        case 2: //right
          var mouse = new THREE.Vector2;
          mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
          mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);

          var intersects = raycaster.intersectObjects(scene.children, false);
          if ((intersects[0].object.name != "building") && (isSelected)) {
            selectedObject.material.color = selectedObjectColor;
            isSelected = false;
            // console.log('Deselected');
          }
          break;
      }
    }

    document.addEventListener('mousedown', onDocumentMouseDown, false);

    //create the webgl renderer
    var renderer = new THREE.WebGLRenderer();

    //set the size of the rendering window
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    //add the renderer to the current document
    document.body.appendChild(renderer.domElement);

    var ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.3);
    var light = new THREE.DirectionalLight(0xFFFFFF, 0.5);
    light.position.y = 1000;
    light.position.x = 500;
    light.position.z = 500;
    light.target.position.set(0, 0, 0);
    light.castShadow = true;
    light.shadow.camera.left = -2000;
    light.shadow.camera.right = 2000;
    light.shadow.camera.top = 2000;
    light.shadow.camera.bottom = -2000;
    light.shadow.camera.far = 4000;
    //var spotLightHelper = new THREE.SpotLightHelper( light );
    var helper = new THREE.CameraHelper(light.shadow.camera);


    function CreateScene() {
      scene.add(ambientLight);
      scene.add(skybox);
      scene.add(light);
      // scene.add(helper);
    }

    CreateScene();

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.5;
    controls.dampingFactor = 1.5;
    camera.position = Pos;
    camera.lookAt(Dir);

    //Generator Logic
    var update = function () {
      controls.update();
    };

    var render = function () {
      //call the render with the scene and the camera
      renderer.render(scene, camera);
    }

    //this fucntion is called when the window is resized
    var MyResize = function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };

    //Runs the game loop
    var GameLoop = function () {

      update();
      // console.log('run update loop');
      // console.log(camera.position);
      // console.log(camera.);
      render();
      requestAnimationFrame(GameLoop);
    }

    requestAnimationFrame(GameLoop);
    //link the resize of the window to the update of the camera
    window.addEventListener('resize', MyResize);

    var gui;
    var params = {
      selected_building: "empty",
      light_angle: Math.PI / 2,
      camera_rotate_speed: 1.5,
      walk_path_steps: 20,
      generate: function () {
        GenerateCity(genSteps);
      }
    }

    function buildGui() {
      gui = new dat.GUI({
        name: "City Options"
      });



      selectCheck();

      var lightFolder = gui.addFolder('Light Options');
      lightFolder.open();

      var lightController = lightFolder.add(params, 'light_angle', 0, Math.PI * 2);
      lightController.name("Angle");
      lightController.onChange(function (val) {
        light.position.y = Math.sin(val) * 1000;
        light.position.x = Math.cos(val) * 1000;
        var lightVal = Math.abs(Math.sin(val));
        light.color = new THREE.Color(1, lightVal, lightVal);
        if (val >= Math.PI) {
          light.intensity = 0;
          ambientLight.intensity = 0.1;
        } else {
          light.intensity = 0.25 + 0.25 * lightVal;
          ambientLight.intensity = 0.1 + 0.2 * lightVal;
        }
      });



      var cameraFolder = gui.addFolder('Camera Options');
      cameraFolder.open();

      var cameraSpeedController = cameraFolder.add(params, 'camera_rotate_speed', 0, 5, 0.1);
      cameraSpeedController.name("Rotate Speed");
      cameraSpeedController.onChange(function (val) {
        controls.autoRotateSpeed = val;
      });



      var generationFolder = gui.addFolder('Generation Options');
      generationFolder.open();

      var genStepsController = generationFolder.add(params, 'walk_path_steps', 1, 60, 1);
      genStepsController.name("Generation Steps");
      genStepsController.onChange(function (val) {
        genSteps = val;
      });

      var genBtn = generationFolder.add(params, 'generate');
      genBtn.name("Generate New City!");


    }

    function selectCheck() {
      if (isSelected == true) {
        var buildingFolder = gui.addFolder('Building Options');
        buildingFolder.open();

        var files = [1, 2, 3, 4, 5, 6, 7, 8];

        var buildingController = buildingFolder.add(params, 'selected_building').listen();
        buildingController.name("Building Options");
        // console.log(selectedObject);
        var paramcolor = {
          color: 0xff00ff
        };
        var paramscale = {
          scale: selectedObjectScale
        };
        buildingFolder.addColor(paramcolor, 'color').name('Building Colour').onChange(function () {
          selectedObjectColor.set(paramcolor.color);
        });
        buildingFolder.add(paramscale, 'scale', 0, 100).onChange(function () {
          selectedObject.scale.y = paramscale.scale;
        });



      }
    }

    buildGui();
  </script>
</body>

</html>